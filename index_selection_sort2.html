<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Selection Sort</title>
	<script src="js/Vector2.js"></script>
	<script src="js/Particle.js"></script>
	<script src="js/fun.js"></script>
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	<script src="js/AlgorithmView2.js"></script>
	<style>
		html,body {
			margin:0;
			padding:10px;
			background: #000;
			font-family: Arial;
			position: relative;
		}
		#counter {
			position: absolute;
			top: 20px;
			left: 20px;
			color:#fff;
			font-size: 20px
		}
		#traces {
			position: absolute;
			top:10px;
			left:10px;
		}
		#stepper {
			position: absolute;
			top:300px;
			left:10px;
			color:#fff;
			width: 80px;
		}
		#stepper span {
			min-width: 30px;
			display: block;
			float: left;
			text-align: center;
		}
		#stepper a {
			color:#fff;
			text-decoration: none;
			float: left;
			display: block;
		}
		#stepper a:hover {
			color:#ffff00;
		}
		svg path {
			stroke-opacity:0;
			stroke-width:1;
			fill:none;
			stroke:#ffffff;
		}
		svg .visible path {
			stroke-opacity:0.6;
		}
		path.highlight {
			stroke-opacity:1;
			stroke-width:2;
		}
		svg circle {
			fill:#fff;
			fill-opacity:0.6;
		}
		svg .circle text {
			fill:#22abef;
			font-size: 10px;
			font-family: Arial;
		}
	</style>
</head>
<body>
	<canvas id="particles"></canvas>
	<div id="traces"></div>
	<div id="stepper">
		<a href="#">&lt;</a>
		&nbsp;
		<span>0</span>
		&nbsp;
		<a href="#">&gt;</a>
	</div>
	<span id="counter"></span>
	<script>

		var	WIDTH=1000,
		   	HEIGHT=800;

		var	canvas=document.getElementById("particles"),
		   	ctx=canvas.getContext("2d");

		canvas.width=WIDTH;
		canvas.height=HEIGHT;

		var data=[];
		var data2=[];

		var NUMBERS=6;

		var qs_callback=null;


		function addData(data) {
			data.push({
				index:data.length,
			})
		}
		

		function shuffle(o){ //v1.0
			console.log("shuffling")
			for(var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
			return o;
		};

		function compareArray(a,b) {
			//console.log(a,b)
			for(var i=0;i<a.length;i++) {
				if(a[i]!=b[i]) {
					//console.log(false)
					return false;
				}
			}
			//console.log(true)
			return true;
		}

		function getOrder(A) {
			var B=[];
			for(var i=0;i<A.length;i++) {
				B.push(A[i].index);
			}
			return B;
		}
		
		var steps=[];

		function Shellsort(nums) {

		    var tempoSS = new Date();
		    var n = nums.length;
		    //console.log("n = ",n);

		    // HERE:
		    var h = Math.floor(n / 2);

		    

		    //console.log("h = ",h);
		    var c, j;

		    //gaps => Math.floor(n/(2**k)) --> original gaps by Shell 1959
		    //h=n/2, then gaps are h/2,h/4,h/8,h/16
		    //n=100 => 50,25,12,6,3,1,0

		    var gaps=[701, 301, 132, 57, 23, 10, 4, 1];

		    while (gaps.length) {
		        for (var i = h; i < n; i++) {

		        	steps.push([]);

		            c = nums[i];
		            j = i;
		            while (j >= h && nums[j - h].index > c.index) {

		            	steps[steps.length-1].push({
			            	index:nums[j - h].index,
			            	from:j - h,
			            	to:j
			            });

		                nums[j] = nums[j - h];
		                j = j - h;
		    			
		            }
		            nums[j] = c;

		    		steps[steps.length-1].push({
		            	index:c.index,
		            	from:i,
		            	to:j
		            });
		    		
		    		var new_items=getOrder(nums);
		    		if(items.length>0 && compareArray(items[items.length-1],new_items)) {
		    			steps.pop();
		    		} else {
		    			items.push(new_items);
		    		}
		            
		        }

		        // AND HERE:
		        //h = Math.floor(h / 2);
		        h=gaps.pop();
		    //console.log("h = ",h);
		    }
		}

		/*
		
		int i,j;
		int iMin;
		 
		
		for (j = 0; j < n-1; j++) {
		    
		 
		    
		    iMin = j;
		    
		    for ( i = j+1; i < n; i++) {
		        
		        if (a[i] < a[iMin]) {
		            
		            iMin = i;
		        }
		    }
		 
		    
		    if ( iMin != j ) {
		        swap(a[j], a[iMin]);
		    }
		}
		*/

		function Selectionsort(nums) {
			var i;
			var iMin;
			/* advance the position through the entire array */
			/*   (could do j < n-1 because single element is also min element) */
			for(var j=0;j<nums.length-1;j++) {

				

				/* find the min element in the unsorted a[j .. n-1] */
				/* assume the min is the first element */
				iMin=j;
				/* test against elements after j to find the smallest */
				for(var i=j+1;i<nums.length;i++) {
					/* if this element is less, then it is the new minimum */
					if(nums[i].index < nums[iMin].index) {
						/* found new minimum; remember its index */
						iMin=i;
					}
				}
				/* iMin is the index of the minimum element. Swap it with the current position */
				if(iMin != j) {
					steps.push([]);

					var tmp1={index:nums[j].index},
						tmp2={index:nums[iMin].index};

					steps[steps.length-1].push({
		            	index:tmp1.index,
		            	from:j,
		            	to:iMin
		            });
		            steps[steps.length-1].push({
		            	index:tmp2.index,
		            	from:iMin,
		            	to:j
		            });

					nums[j]=tmp2;
					nums[iMin]=tmp1;

					var new_items=getOrder(nums);
					items.push(new_items);

				}
			}
		}

		for(var i=0;i<NUMBERS;i++) {
			addData(data2);
		}

		shuffle(data2);
		//data2.reverse();

		data2=[{"index":6},{"index":0},{"index":8},{"index":11},{"index":4},{"index":17},{"index":15},{"index":7},{"index":1},{"index":16},{"index":3},{"index":12},{"index":9},{"index":5},{"index":19},{"index":14},{"index":2},{"index":10},{"index":18},{"index":13}];
		
		for(var i=0;i<data2.length;i++) {
			data[i]=data2[i];
		}


		var items=[];
		items.push(getOrder(data2));

		//console.log(items)

		Selectionsort(data2);

		//items.push(getOrder(data2));

		/*
		var steps=[];
		var already=[];
		for(var i=1;i<items.length;i++) {
			var prev=items[i-1],
				curr=items[i];
			steps[i-1]=[];
			already[i-1]=[];
			for(var j=0;j<prev.length;j++) {
				var curr_j=curr.indexOf(prev[j]);
				if(curr_j!=j) {
					if(already[i-1].indexOf(prev[j]+"-"+curr[j])==-1 && already[i-1].indexOf(curr[j]+"-"+prev[j])==-1) {
						steps[i-1].push({
							to:curr_j,
							to:j,
							fromE:prev[j],
							toE:curr[j]
						});
					}
					already[i-1].push(prev[j]+"-"+curr[j]);
				}
			}
		}
		*/


		
		items.forEach(function(d,i){
			if(i>0)
				console.log(steps[i-1])
			console.log(d);
			
		});
		
		

		
		var qs_view=new AlgorithmView({
			container:"#traces",
			width:WIDTH,
			height:HEIGHT,
			steps:steps.filter(function(d){
				return d.length>0;
			}),
			items:items,
			grouping:1,
			callback:function(){
				d3.select("#stepper span")
					.text(qs_view.getStepsLength() - qs_view.getCurrentStep())
			}
		});
		
		//qs_view.show(0);

		d3.select("#stepper span").text(steps.filter(function(d){
			return d.length>0;
		}).length);

		d3.selectAll("#stepper a")
			.on("click",function(d,i){
				d3.event.preventDefault();
				if(i>0)
					qs_view.stepNext();
				if(i<1)
					qs_view.stepPrev();

				//d3.select("#stepper span")
				//	.text(qs_view.getStepsLength() - qs_view.getCurrentStep())

			})

	</script>
</body>
</html>
